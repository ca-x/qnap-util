package main

import (
	"archive/tar"
	"bufio"
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// QPKG Extractor
// Script to extract the data within a QPKG file.
// (Another way to do this is using the QDK tool)
//
// A QPKG package starts with a short shell script followed by data blocks.
// The data blocks are usually *.tar.gz archives.
// This script extracts the header script until it finds a line starting with
// the word "exit". It then searches and extracts *.tar.gz parts by looking
// for gzip headers (starting with the byte sequence '1f 8b 08 00') in the file.
//
// Copyright 2015 Max BÃ¶hm (original bash version)
// Go conversion 2025

func main() {
	if len(os.Args) < 2 {
		fmt.Printf("usage: %s package.qpkg [destdir]\n", os.Args[0])
		os.Exit(1)
	}

	src := os.Args[1]
	var dest string
	if len(os.Args) >= 3 {
		dest = os.Args[2]
	} else {
		// Remove extension from source filename
		dest = strings.TrimSuffix(src, filepath.Ext(src))
	}

	// Check if destination directory already exists
	if _, err := os.Stat(dest); !os.IsNotExist(err) {
		fmt.Printf("destdir '%s' must not already exist\n", dest)
		os.Exit(1)
	}

	fmt.Printf("SRC=%s, DEST=%s\n", src, dest)

	// Create destination directory
	if err := os.MkdirAll(dest, 0755); err != nil {
		fmt.Printf("error creating destination directory: %v\n", err)
		os.Exit(1)
	}

	// Extract QPKG header script
	headerPath := filepath.Join(dest, "header_script")
	fmt.Printf("extracting '%s' ...\n", headerPath)

	skip, err := extractHeaderScript(src, headerPath)
	if err != nil {
		fmt.Printf("error extracting header script: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("%d bytes.\n", skip)

	// Extract payload
	payloadPath := filepath.Join(dest, "payload")
	if err := extractPayload(src, payloadPath, skip); err != nil {
		fmt.Printf("error extracting payload: %v\n", err)
		os.Exit(1)
	}

	// Extract tar.gz parts
	partNames := []string{"control", "data", "extra"} // convention for QPKG packages generated by QDK
	if err := extractParts(payloadPath, dest, partNames); err != nil {
		fmt.Printf("error extracting parts: %v\n", err)
		os.Exit(1)
	}

	// Remove payload file
	os.Remove(payloadPath)
}

// extractHeaderScript extracts the header script until it finds a line starting with "exit"
func extractHeaderScript(srcPath, headerPath string) (int64, error) {
	srcFile, err := os.Open(srcPath)
	if err != nil {
		return 0, err
	}
	defer srcFile.Close()

	headerFile, err := os.Create(headerPath)
	if err != nil {
		return 0, err
	}
	defer headerFile.Close()

	scanner := bufio.NewScanner(srcFile)
	var bytesWritten int64

	for scanner.Scan() {
		line := scanner.Text()
		lineWithNewline := line + "\n"

		// Write the line to header file
		n, err := headerFile.WriteString(lineWithNewline)
		if err != nil {
			return 0, err
		}
		bytesWritten += int64(n)

		// Check if line starts with "exit"
		if strings.HasPrefix(strings.TrimSpace(line), "exit") {
			break
		}
	}

	return bytesWritten, scanner.Err()
}

// extractPayload extracts the payload part after skipping the header
func extractPayload(srcPath, payloadPath string, skip int64) error {
	srcFile, err := os.Open(srcPath)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	payloadFile, err := os.Create(payloadPath)
	if err != nil {
		return err
	}
	defer payloadFile.Close()

	// Skip the header bytes
	if _, err := srcFile.Seek(skip, io.SeekStart); err != nil {
		return err
	}

	// Copy the rest to payload file
	_, err = io.Copy(payloadFile, srcFile)
	return err
}

// findGzipHeaders finds all offsets where gzip headers (1f 8b 08 00) occur
func findGzipHeaders(data []byte) []int64 {
	var offsets []int64
	gzipHeader := []byte{0x1f, 0x8b, 0x08, 0x00}

	for i := 0; i <= len(data)-len(gzipHeader); i++ {
		if bytes.Equal(data[i:i+len(gzipHeader)], gzipHeader) {
			offsets = append(offsets, int64(i))
		}
	}

	return offsets
}

// extractParts extracts tar.gz parts from the payload
func extractParts(payloadPath, dest string, partNames []string) error {
	// Read payload file
	payloadData, err := os.ReadFile(payloadPath)
	if err != nil {
		return err
	}

	// Find gzip headers
	offsets := findGzipHeaders(payloadData)

	for i, offset := range offsets {
		if i >= len(partNames) {
			break // No more part names available
		}

		partName := partNames[i]
		partPath := filepath.Join(dest, partName)

		fmt.Printf("- extracting '%s.tar.gz' at offset %d into '%s' ...\n", partPath, offset, partPath)

		// Extract tar.gz from payload starting at offset
		var partData []byte
		if i < len(offsets)-1 {
			// Not the last part, extract until next gzip header
			partData = payloadData[offset:offsets[i+1]]
		} else {
			// Last part, extract until end of file
			partData = payloadData[offset:]
		}

		// Find the actual end of this gzip stream
		partData = findGzipEnd(partData)

		// Save as tar.gz file
		tarGzPath := partPath + ".tar.gz"
		if err := os.WriteFile(tarGzPath, partData, 0644); err != nil {
			return err
		}

		// Decompress gzip
		tarPath := partPath + ".tar"
		if err := decompressGzip(tarGzPath, tarPath); err != nil {
			fmt.Printf("warning: failed to decompress %s: %v\n", tarGzPath, err)
			continue
		}

		// Create directory for extracted files
		if err := os.MkdirAll(partPath, 0755); err != nil {
			return err
		}

		// Extract tar archive
		if err := extractTar(tarPath, partPath); err != nil {
			return err
		}

		// Clean up temporary files
		os.Remove(tarGzPath)
		os.Remove(tarPath)
	}

	return nil
}

// findGzipEnd attempts to find the end of a gzip stream
func findGzipEnd(data []byte) []byte {
	// Try to decompress to find the actual end
	reader := bytes.NewReader(data)
	gzReader, err := gzip.NewReader(reader)
	if err != nil {
		return data // Return original data if can't create gzip reader
	}
	defer gzReader.Close()

	// Read all data to find the end
	_, err = io.ReadAll(gzReader)
	if err != nil {
		return data // Return original data if can't read
	}

	// Calculate how much was actually read
	consumed := len(data) - reader.Len()
	return data[:consumed]
}

// decompressGzip decompresses a gzip file
func decompressGzip(gzipPath, outputPath string) error {
	gzipFile, err := os.Open(gzipPath)
	if err != nil {
		return err
	}
	defer gzipFile.Close()

	gzReader, err := gzip.NewReader(gzipFile)
	if err != nil {
		return err
	}
	defer gzReader.Close()

	outputFile, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer outputFile.Close()

	_, err = io.Copy(outputFile, gzReader)
	return err
}

// extractTar extracts a tar archive to a directory
func extractTar(tarPath, destDir string) error {
	tarFile, err := os.Open(tarPath)
	if err != nil {
		return err
	}
	defer tarFile.Close()

	tarReader := tar.NewReader(tarFile)

	for {
		header, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}

		target := filepath.Join(destDir, header.Name)

		// Ensure the target path is within destDir (security check)
		if !strings.HasPrefix(target, filepath.Clean(destDir)+string(os.PathSeparator)) {
			return fmt.Errorf("invalid file path: %s", header.Name)
		}

		switch header.Typeflag {
		case tar.TypeDir:
			if err := os.MkdirAll(target, os.FileMode(header.Mode)); err != nil {
				return err
			}
		case tar.TypeReg:
			// Create directory for file if it doesn't exist
			if err := os.MkdirAll(filepath.Dir(target), 0755); err != nil {
				return err
			}

			file, err := os.OpenFile(target, os.O_CREATE|os.O_WRONLY, os.FileMode(header.Mode))
			if err != nil {
				return err
			}

			if _, err := io.Copy(file, tarReader); err != nil {
				file.Close()
				return err
			}
			file.Close()
		}
	}

	return nil
}
